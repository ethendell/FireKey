"""Export utilities for FireKey metadata."""
from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Sequence
import csv
import json
import os
import shutil
import sys
import xml.etree.ElementTree as ET


SUPPORTED_FORMATS = ("CSV", "JSON", "XML")


@dataclass
class ExportSummary:
    """Summary details that accompany an export."""

    model: str = "Unknown"
    tokens: int = 0
    cost: float = 0.0

    def to_dict(self, total_files: int) -> Dict[str, object]:
        return {
            "total_files": total_files,
            "model": self.model,
            "tokens": self.tokens,
            "cost": self.cost,
            "generated_at": datetime.utcnow().isoformat() + "Z",
        }


@dataclass
class ExportResult:
    """Describes the output generated by an export."""

    format: str
    folder: Optional[Path] = None
    metadata_path: Optional[Path] = None
    summary_path: Optional[Path] = None
    poster_frame_paths: Sequence[Path] = ()

    @property
    def has_folder(self) -> bool:
        return self.folder is not None


class Exporter:
    """Coordinates writing metadata files in several formats."""

    def __init__(self, base_export_dir: Path | str = "exports") -> None:
        self.base_export_dir = Path(base_export_dir)
        self.base_export_dir.mkdir(parents=True, exist_ok=True)

    # Public API ---------------------------------------------------------
    def export(
        self,
        records: Sequence[Dict[str, object]],
        fmt: str,
        summary: Optional[ExportSummary] = None,
        *,
        include_poster_frames: bool = True,
        output_path: Optional[Path] = None,
    ) -> ExportResult:
        fmt = fmt.upper()
        if output_path is not None:
            output_path = Path(output_path)
        if fmt not in SUPPORTED_FORMATS:
            raise ValueError(f"Unsupported export format: {fmt}")
        if fmt == "CSV":
            if output_path is not None:
                raise ValueError("CSV exports manage their own folder; omit output_path.")
            return self._export_csv(records, summary, include_poster_frames=include_poster_frames)
        if fmt == "JSON":
            return self._export_json(records, summary, output_path)
        return self._export_xml(records, summary, output_path)

    # Implementation helpers --------------------------------------------
    def _export_csv(
        self,
        records: Sequence[Dict[str, object]],
        summary: Optional[ExportSummary],
        *,
        include_poster_frames: bool,
    ) -> ExportResult:
        export_folder = self._create_timestamped_folder()
        metadata_path = export_folder / "metadata.csv"
        summary_path = export_folder / "summary.json"

        if not records:
            raise ValueError("CSV export requires at least one record")

        headers = self._collect_headers(records)
        with metadata_path.open("w", newline="", encoding="utf-8") as csv_file:
            writer = csv.DictWriter(csv_file, fieldnames=headers)
            writer.writeheader()
            for record in records:
                writer.writerow(self._stringify_values(record))

        summary_data = self._build_summary(records, summary)
        summary_path.write_text(json.dumps(summary_data, indent=2), encoding="utf-8")

        poster_paths: List[Path] = []
        if include_poster_frames:
            poster_paths = self._copy_poster_frames(records, export_folder)

        return ExportResult(
            format="CSV",
            folder=export_folder,
            metadata_path=metadata_path,
            summary_path=summary_path,
            poster_frame_paths=poster_paths,
        )

    def _export_json(
        self,
        records: Sequence[Dict[str, object]],
        summary: Optional[ExportSummary],
        output_path: Optional[Path],
    ) -> ExportResult:
        data = {
            "summary": self._build_summary(records, summary),
            "records": [self._json_ready_record(record) for record in records],
        }
        if output_path is None:
            output_path = self._create_timestamped_file("metadata", ".json")
        else:
            output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(json.dumps(data, indent=2), encoding="utf-8")
        return ExportResult(format="JSON", metadata_path=output_path)

    def _export_xml(
        self,
        records: Sequence[Dict[str, object]],
        summary: Optional[ExportSummary],
        output_path: Optional[Path],
    ) -> ExportResult:
        root = ET.Element("firekey")
        summary_element = ET.SubElement(root, "summary")
        for key, value in self._build_summary(records, summary).items():
            child = ET.SubElement(summary_element, key)
            child.text = str(value)
        records_element = ET.SubElement(root, "records")
        for record in records:
            record_element = ET.SubElement(records_element, "record")
            for key, value in record.items():
                child = ET.SubElement(record_element, key)
                child.text = "" if value is None else str(value)
        tree = ET.ElementTree(root)
        if output_path is None:
            output_path = self._create_timestamped_file("metadata", ".xml")
        else:
            output_path.parent.mkdir(parents=True, exist_ok=True)
        tree.write(output_path, encoding="utf-8", xml_declaration=True)
        return ExportResult(format="XML", metadata_path=output_path)

    def _build_summary(
        self,
        records: Sequence[Dict[str, object]],
        summary: Optional[ExportSummary],
    ) -> Dict[str, object]:
        if summary is None:
            summary = ExportSummary()
        return summary.to_dict(total_files=len(records))

    def _create_timestamped_folder(self) -> Path:
        timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
        folder = self.base_export_dir / timestamp
        folder.mkdir(parents=True, exist_ok=True)
        return folder

    def _create_timestamped_file(self, base_name: str, extension: str) -> Path:
        timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
        filename = f"{base_name}_{timestamp}{extension}"
        file_path = self.base_export_dir / filename
        file_path.parent.mkdir(parents=True, exist_ok=True)
        return file_path

    def _collect_headers(self, records: Sequence[Dict[str, object]]) -> List[str]:
        headers: List[str] = []
        for record in records:
            for key in record.keys():
                if key not in headers:
                    headers.append(key)
        return headers

    def _stringify_values(self, record: Dict[str, object]) -> Dict[str, str]:
        return {key: "" if value is None else str(value) for key, value in record.items()}

    def _json_ready_record(self, record: Dict[str, object]) -> Dict[str, object]:
        json_record: Dict[str, object] = {}
        for key, value in record.items():
            if isinstance(value, Path):
                json_record[key] = str(value)
            else:
                json_record[key] = value
        return json_record

    def _copy_poster_frames(
        self,
        records: Sequence[Dict[str, object]],
        export_folder: Path,
    ) -> List[Path]:
        copied: List[Path] = []
        poster_dir = export_folder / "poster_frames"
        for record in records:
            path_value = record.get("poster_frame")
            if not path_value:
                continue
            path = Path(path_value)
            if not path.exists():
                continue
            poster_dir.mkdir(parents=True, exist_ok=True)
            destination = poster_dir / path.name
            shutil.copy2(path, destination)
            copied.append(destination)
        return copied


def open_folder(path: Path) -> None:
    """Open the path in the OS file explorer."""
    if sys.platform == "win32":
        try:
            os.startfile(path)  # type: ignore[attr-defined]
        except Exception as exc:  # pragma: no cover - platform specific
            raise RuntimeError("Could not open folder") from exc
    else:
        import subprocess

        command = ["open" if sys.platform == "darwin" else "xdg-open", str(path)]
        try:
            subprocess.check_call(command)
        except Exception as exc:  # pragma: no cover - best effort
            raise RuntimeError("Could not open folder") from exc
